<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>U²-Net Browser Background Remover</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 2rem;
      background: #f4f4f4;
    }
    h1 { margin-bottom: .5rem; }

    /* Spinner */
    .spinner {
      margin: 1rem auto;
      width: 48px;
      height: 48px;
      border: 5px solid rgba(0,0,0,0.1);
      border-top-color: #007BFF;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      display: none;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Controls */
    #controls {
      margin: 1rem 0;
    }
    input, button {
      margin: .5rem;
      padding: .6rem 1.2rem;
      font-size: 1rem;
      cursor: pointer;
    }

    /* Status */
    #status {
      font-size: .95rem;
      color: #333;
      min-height: 1.2em;
    }

    /* Output */
    canvas, img.preview {
      max-width: 90%;
      margin: 1rem auto;
      display: block;
      border: 1px solid #ccc;
      background: white;
    }
    a.download {
      display: inline-block;
      margin-top: 1rem;
      padding: .6rem 1.2rem;
      text-decoration: none;
      border-radius: 4px;
      background: #007BFF;
      color: white;
    }
    a.download:hover { background: #0056b3 }
  </style>
</head>
<body>
  <h1>Browser-Only U²-Net Background Remover</h1>
  <div id="controls">
    <input type="file" id="fileInput" accept="image/*"/>
    <button id="runBtn" disabled>Remove Background</button>
  </div>

  <div class="spinner" id="spinner"></div>
  <div id="status">Initializing…</div>

  <canvas id="hiddenCanvas" style="display:none;"></canvas>
  <img id="preview" class="preview" style="display:none" alt="Result"/>
  <a id="downloadLink" class="download" style="display:none">Download PNG</a>

  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <script>
    const statusEl = document.getElementById('status');
    const spinner  = document.getElementById('spinner');
    const runBtn   = document.getElementById('runBtn');
    const fileIn   = document.getElementById('fileInput');
    const canvas   = document.getElementById('hiddenCanvas');
    const preview  = document.getElementById('preview');
    const download = document.getElementById('downloadLink');

    let session, inputName, outputName;

    function setStatus(text, busy = false) {
      statusEl.textContent = text;
      spinner.style.display = busy ? 'block' : 'none';
    }

    // 1) Load model from jsDelivr (CORS-friendly) and capture its input/output names
    (async () => {
      setStatus('Loading U²-Net model… (~176 MB)', true);
      try {
        session = await ort.InferenceSession.create(
          'https://cdn.jsdelivr.net/gh/xuebinqin/U-2-Net@v1.0/u2net.onnx',
          { executionProviders: ['wasm'], graphOptimizationLevel: 'all' }
        );
        // grab the first input & output names dynamically
        inputName  = session.inputNames[0];
        outputName = session.outputNames[0];
        setStatus('Model loaded ✓ Ready to remove backgrounds.', false);
        runBtn.disabled = false;
      } catch (e) {
        console.error(e);
        setStatus('❌ Failed to load model. Check your connection.', false);
      }
    })();

    // Enable “Remove” when a file is selected
    fileIn.addEventListener('change', () => {
      runBtn.disabled = !fileIn.files.length;
    });

    // 2) Run inference on click
    runBtn.addEventListener('click', async () => {
      if (!fileIn.files.length || !session) return;
      setStatus('Processing image…', true);
      runBtn.disabled = true;
      preview.style.display = download.style.display = 'none';

      // Load image into a temporary <img>
      const img = new Image();
      img.src = URL.createObjectURL(fileIn.files[0]);
      await new Promise(r => img.onload = r);

      // Draw & resize to 320×320 on hidden canvas
      const W = img.naturalWidth, H = img.naturalHeight;
      const ctx = canvas.getContext('2d');
      canvas.width = canvas.height = 320;
      ctx.clearRect(0,0,320,320);
      const scale = Math.min(320/W, 320/H);
      ctx.drawImage(img, 0,0, W,H, 0,0, W*scale, H*scale);

      // Build input tensor [1,3,320,320]
      const imgData = ctx.getImageData(0,0,320,320).data;
      const float32 = new Float32Array(3*320*320);
      for (let y = 0; y < 320; y++) {
        for (let x = 0; x < 320; x++) {
          const i = (y*320 + x)*4;
          float32[y*320 + x]              = (imgData[i+0]/255 - 0.485)/0.229;
          float32[1*320*320 + y*320 + x]  = (imgData[i+1]/255 - 0.456)/0.224;
          float32[2*320*320 + y*320 + x]  = (imgData[i+2]/255 - 0.406)/0.225;
        }
      }
      const tensor = new ort.Tensor('float32', float32, [1,3,320,320]);

      // Inference
      let output;
      try {
        output = await session.run({ [inputName]: tensor });
      } catch (e) {
        console.error(e);
        setStatus('❌ Inference failed.', false);
        runBtn.disabled = false;
        return;
      }

      // Extract the mask and composite it back at full resolution
      const maskData = output[outputName].data; // float32[320*320]
      canvas.width = W; canvas.height = H;
      ctx.clearRect(0,0,W,H);
      ctx.drawImage(img, 0,0, W,H);
      const fullImage = ctx.getImageData(0,0,W,H);

      // Nearest-neighbor upsample mask → alpha channel
      for (let y = 0; y < H; y++) {
        const yy = Math.floor(y * 320 / H);
        for (let x = 0; x < W; x++) {
          const xx = Math.floor(x * 320 / W);
          const a  = Math.round(maskData[yy*320 + xx] * 255);
          fullImage.data[(y*W + x)*4 + 3] = a;
        }
      }
      ctx.putImageData(fullImage, 0, 0);

      // Show result & download link
      const dataUrl = canvas.toDataURL('image/png');
      preview.src = dataUrl;
      preview.style.display = 'block';
      download.href = dataUrl;
      download.download = 'no-bg.png';
      download.style.display = 'inline-block';

      setStatus('Done! You can download your PNG ↓', false);
      runBtn.disabled = false;
    });
  </script>
</body>
</html>
