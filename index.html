<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>U²-Net Browser Background Remover</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 2rem;
      background: #f4f4f4;
    }
    h1 { margin-bottom: .5rem; }

    /* Spinner */
    .spinner {
      margin: 1rem auto;
      width: 48px;
      height: 48px;
      border: 5px solid rgba(0,0,0,0.1);
      border-top-color: #007BFF;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      display: none;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Controls */
    #controls {
      margin: 1rem 0;
    }
    input, button {
      margin: .5rem;
      padding: .6rem 1.2rem;
      font-size: 1rem;
      cursor: pointer;
    }

    /* Status */
    #status {
      font-size: .95rem;
      color: #333;
      min-height: 1.2em;
    }

    /* Output */
    canvas, img.preview {
      max-width: 90%;
      margin: 1rem auto;
      display: block;
      border: 1px solid #ccc;
      background: white;
    }
    a.download {
      display: inline-block;
      margin-top: 1rem;
      padding: .6rem 1.2rem;
      text-decoration: none;
      border-radius: 4px;
      background: #007BFF;
      color: white;
    }
    a.download:hover { background: #0056b3 }
  </style>
</head>
<body>
  <h1>Browser-Only U²-Net Background Remover</h1>
  <div id="controls">
    <input type="file" id="fileInput" accept="image/*"/>
    <button id="runBtn" disabled>Remove Background</button>
  </div>

  <div class="spinner" id="spinner"></div>
  <div id="status">Initializing...</div>

  <canvas id="hiddenCanvas" style="display:none;"></canvas>
  <img id="preview" class="preview" style="display:none" alt="Result"/>
  <a id="downloadLink" class="download" style="display:none">Download PNG</a>

  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <script>
    const statusEl = document.getElementById('status');
    const spinner  = document.getElementById('spinner');
    const runBtn   = document.getElementById('runBtn');
    const fileIn   = document.getElementById('fileInput');
    const canvas   = document.getElementById('hiddenCanvas');
    const preview  = document.getElementById('preview');
    const download = document.getElementById('downloadLink');

    // Helper to show/hide spinner+status
    function setStatus(text, busy=false) {
      statusEl.textContent = text;
      spinner.style.display = busy ? 'block' : 'none';
    }

    // 1) Load model
    (async () => {
      setStatus('Loading U²-Net model… (~176 MB)', true);
      window.session = await ort.InferenceSession.create(
        'https://github.com/xuebinqin/U-2-Net/raw/master/u2net.onnx',
        { executionProviders: ['wasm'], graphOptimizationLevel: 'all' }
      );
      setStatus('Model loaded ✓ Ready to remove backgrounds.', false);
      runBtn.disabled = false;
    })().catch(err => {
      console.error(err);
      setStatus('❌ Failed to load model.', false);
    });

    // Enable “Remove” when file selected
    fileIn.addEventListener('change', () => {
      runBtn.disabled = !fileIn.files.length;
    });

    // 2) Run inference on click
    runBtn.addEventListener('click', async () => {
      if (!fileIn.files.length) return;
      setStatus('Processing image…', true);
      runBtn.disabled = true;
      preview.style.display = download.style.display = 'none';

      // Load & draw to 320×320 canvas
      const img = new Image();
      img.src = URL.createObjectURL(fileIn.files[0]);
      await new Promise(r => img.onload = r);
      const W = img.naturalWidth, H = img.naturalHeight;
      const ctx = canvas.getContext('2d');
      // draw resized to 320×320
      canvas.width = canvas.height = 320;
      ctx.clearRect(0,0,320,320);
      const scale = Math.min(320/W, 320/H);
      ctx.drawImage(img, 0,0, W,H, 0,0, W*scale, H*scale);

      // Build input tensor
      const data = ctx.getImageData(0,0,320,320).data;
      const float32 = new Float32Array(3*320*320);
      for (let y=0; y<320; y++) for (let x=0; x<320; x++) {
        const i = (y*320 + x)*4;
        // normalize to ImageNet
        float32[y*320 + x]              = (data[i+0]/255 - 0.485)/0.229;
        float32[1*320*320 + y*320 + x]  = (data[i+1]/255 - 0.456)/0.224;
        float32[2*320*320 + y*320 + x]  = (data[i+2]/255 - 0.406)/0.225;
      }
      const tensor = new ort.Tensor('float32', float32, [1,3,320,320]);

      // Run model
      let output;
      try {
        output = await session.run({ 'input.1': tensor });
      } catch (e) {
        console.error(e);
        setStatus('❌ Inference failed.', false);
        runBtn.disabled = false;
        return;
      }

      // Extract mask & upsample to original size
      const maskData = output['187'].data; // final U²-Net output
      // Prepare full-res canvas
      canvas.width = W; canvas.height = H;
      ctx.clearRect(0,0,W,H);
      ctx.drawImage(img, 0,0, W,H);
      const imgBytes = ctx.getImageData(0,0,W,H);

      // Nearest-neighbor upsample the mask → alpha
      for (let y=0; y<H; y++) {
        const yy = Math.floor(y*320/H);
        for (let x=0; x<W; x++) {
          const xx = Math.floor(x*320/W);
          const v  = maskData[yy*320 + xx];
          imgBytes.data[(y*W+x)*4 + 3] = Math.round(v*255);
        }
      }
      ctx.putImageData(imgBytes, 0,0);

      // Show result + download
      const url = canvas.toDataURL('image/png');
      preview.src = url; preview.style.display = 'block';
      download.href = url; download.download = 'no-bg.png';
      download.style.display = 'inline-block';

      setStatus('Done! You can download your PNG ↓', false);
      runBtn.disabled = false;
    });
  </script>
</body>
</html>
